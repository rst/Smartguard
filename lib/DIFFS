access_form_helpers.rb
--- access_form_helpers.rb	2008-05-12 16:44:43.000000000 -0400
+++ /home/rst/test/trunk/lib/access_form_helpers.rb	2008-05-12 15:29:48.000000000 -0400
@@ -1,24 +1,3 @@
-#--
-# Copyright (c) 2007 Robert S. Thau, Smartleaf, Inc.
-# 
-# a copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be
-# included in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#++
 module Access
 
   module Sensitive
access.rb
--- access.rb	2008-05-12 16:44:43.000000000 -0400
+++ /home/rst/test/trunk/lib/access.rb	2008-05-12 15:29:48.000000000 -0400
@@ -1,24 +1,7 @@
-#--
-# Copyright (c) 2007 Robert S. Thau, Smartleaf, Inc.
-# 
-# a copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be
-# included in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#++
+require 'access_test_helpers'
+require 'access_db_helpers'
+require 'access_form_helpers'
+require 'access_require_privilege'
 
 # An extended SecurityError for permission failures.
 # 
@@ -48,52 +31,28 @@
 
     module ClassMethods
 
-      # Sole argument is an array of strings that name attributes that
-      # are possible access keys for this class.  Note, if 'foo' is
-      # used by any access-controlled model as an access control key,
-      # there *must* be a corresponding column in the class's database
-      # table (and not be, e.g., a computed pseudo-attribute), and
-      # Permission objects *must* have a 'target_foo' attribute, again
-      # with a corresponding column in the 'permissions' table.
-
-      def declare_access_control_keys( *ack_list )
-        ack_list = ack_list.collect( &:to_s )
-        instance_eval <<-EOF
-          def self.access_control_keys; #{ack_list.inspect}; end
-        EOF
-      end
-
-      def access_control_keys   # :nodoc:
-        # Defaults
-        if @all_acks.nil?
-          @all_acks = []
-          @all_acks <<= 'id'
-          owner_ack = self.owner_access_control_key
-          @all_acks << owner_ack unless (owner_ack.nil? || owner_ack == 'id')
-        end
-        @all_acks
+      # Returns an array of strings that name attributes that
+      # are possible access keys for this class.  May be overridden
+      # by classes to add keys; but note, if 'foo' is listed here
+      # as an access control key, it *must* have a corresponding
+      # column in the class's database table (and not be, e.g., 
+      # a computed pseudo-attribute), and Permission objects
+      # *must* have a 'target_foo' attribute, again with a
+      # corresponding column in the 'permissions' table.
+
+      def access_control_keys
+        [ 'owner_id', 'owner_firm_id', 'id' ]
       end
 
-      # Argument is a string naming the access key attribute 
-      # that contains the id of the owner in the users table,
-      # or nil, to indicate that there is no owner access control
-      # key.
-      #
+      # Returns a string naming the access key attribute that
+      # contains the id of the owner in the users table.
       # Settable for the sake of the User class itself, which
       # uses 'id' as the owner_access_key, so owned_by_self
       # permissions can be used to grant users selective
       # rights on their passwords, prefs, etc.
 
-      def declare_owner_access_control_key( ack )
-        ack = ack.to_s unless ack.nil?
-        instance_eval <<-EOF
-          def self.owner_access_control_key; #{ack.inspect}; end
-        EOF
-      end
-
-      def owner_access_control_key # :nodoc:
-        # Default behavior
-        @owner_ack ||= column_names.include?('owner_id')? 'owner_id' : nil
+      def owner_access_control_key
+        'owner_id'
       end
 
       # :call-seq:
@@ -185,8 +144,13 @@
 
         user = keyword_args[:user] || User.current
 
+        if user.nil?
+          raise ArgumentError.new("Cannot generate where clause without user")
+        end
+
         keys = { 
           :user       => user,
+          :firm       => user.firm,
           :privilege  => priv.to_s,
           :class_name => self.name,
           :false      => false,
@@ -203,7 +167,7 @@
              where exists (select 'x' from role_assignments
                            where user_id = :user
                              and role_assignments.role_id = p.role_id
-                             and #{RoleAssignment.current_sql_condition})
+                             and #{RoleAssignment::CURRENT_SQL_CONDITION})
                and (p.privilege  = :privilege or p.privilege = 'any')
                and (p.class_name = :class_name)
                and (p.is_grant   = :false)
@@ -258,6 +222,7 @@
 
     def permits?( priv, user = User.current )
       (priv, associate) = disassemble_priv( priv )
+      check_user_set!(user, priv, associate)
       user.can?( priv, associate )
     end
 
@@ -278,6 +243,8 @@
         ((associate.has_attribute?(:name)? associate.name : nil) || 'X')
       log_text = "permission check: #{priv} #{associate_name}(#{associate.id})"
 
+      check_user_set!(user, priv, associate)
+
       log_hash = { 
         :model_class => associate.class.name,
         :model_id    => associate.id,
@@ -289,13 +256,13 @@
       if !user.can?( priv, associate )
         logger.warn "=== FAILED #{log_text}"
         log_hash[:success] = false
-        Smartguard::Logging.log( log_hash )
+        RequestLogEntry.note_pcheck( log_hash )
         raise PermissionFailure.new( "not authorized to #{priv}",
                                      :privilege => priv,
                                      :target    => associate )
       else
         log_hash[:success] = true
-        Smartguard::Logging.log( log_hash )
+        RequestLogEntry.note_pcheck( log_hash )
         logger.warn "=== #{log_text}"
       end
       self
@@ -303,6 +270,14 @@
 
     private
 
+    def check_user_set!(user, priv, associate)
+      if user.nil?
+        raise PermissionFailure.new("Not authorized to #{priv} because " +
+                                    "current user is not set", 
+                                    :privilege => priv, :target => associate)
+      end
+    end
+
     def disassemble_priv( priv )  # :nodoc:
       associate = self
       if priv.is_a?( Array )
access_require_privilege.rb
--- access_require_privilege.rb	2008-05-12 16:44:43.000000000 -0400
+++ /home/rst/test/trunk/lib/access_require_privilege.rb	2008-05-12 15:29:48.000000000 -0400
@@ -1,24 +1,3 @@
-#--
-# Copyright (c) 2007 Robert S. Thau, Smartleaf, Inc.
-# 
-# a copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be
-# included in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#++
 module Access
   module RequirePrivilege
 
@@ -32,6 +11,23 @@
     module ClassMethods
 
       # :call-seq:
+      #   Klass.where_permits_action :action_name[, :user => ...]
+      #
+      # Returns the text of a SQL condition (suitable for use in a 
+      # where clause) which selects records of this class's table
+      # on which the user (default: User.current) is permitted to
+      # perform given action
+
+      def where_permits_action( action, keyword_args = {} )
+        priv = self.callback_privilege( EVENT_CALLBACK_KEYS[ action ] )
+        if priv.nil?
+          return '1 = 1'
+        else
+          return where_permits( priv, keyword_args )
+        end
+      end
+
+      # :call-seq:
       #   (in class definition)
       #   declare_privilege :privilege, :privilege2, ...
       #        e.g.
@@ -475,7 +471,7 @@
         end
       end
 
-      # Declares blocks of attributes to be set before others in attributes=
+      # Returns blocks of attributes to be set before others in attributes=
       # 
       # The problem we're trying to solve here is, say:
       # 
@@ -493,14 +489,8 @@
       # keys that determine whether you can publish, and one for the 
       # published flag itself, followed by the ordinary attributes).
 
-      def declare_attribute_block_set_groups( *groups )
-        instance_eval <<-EOF
-          def self.attribute_block_set_groups; #{groups.inspect}; end
-        EOF
-      end
-
-      def attribute_block_set_groups # :nodoc:
-        [['owner', 'owner_id']]
+      def attribute_block_set_groups
+        [['owner', 'owner_id', 'owner_firm', 'owner_firm_id']]
       end
 
       # Returns true if the user could ever create an object
@@ -586,6 +576,11 @@
         @reflected_privileges[type][key]
       end
 
+      def association_access_control_keys
+        @reflected_privileges ||= reflected_priv_defaults
+        @reflected_privileges[:fk_for_associate].keys
+      end
+
       private
 
       def hack_rp_arg( arg )
@@ -684,6 +679,13 @@
         
       end
 
+      # Returns the normal permissions with any items which are involve access control keys
+      def attributes_sans_access_control_keys
+        acl_keys = self.class.access_control_keys + self.class.association_access_control_keys
+        acl_keys.map!{|x| x.to_s}
+        self.attributes.reject{|k, v| acl_keys.include?(k.to_s)}
+      end
+
       # Returns true if the user has permission to update attribute attr,
       # named by a symbol, e.g. blog.permits_update_attr?( :name )
 
@@ -735,10 +737,10 @@
       end
 
       # :call-seq:
-      #    obj.permitted_associates :association_name
-      #    obj.permitted_associates :association_name
+      #    obj.permitted_associates :owner_firm
+      #    obj.permitted_associates :owner_firm, 
       #                             :conditions => ['name like ?', name]
-      #    obj.permitted_associates :association_name, :include => ...
+      #    obj.permitted_associates :account, :include => :owner_firm
       #    etc.
       #
       # If, say, we have:
@@ -846,7 +848,8 @@
           unless privilege.nil?
 
             all_perms = user.all_permissions( privilege, self.class )
-            all_ids = all_perms.collect{ |perm| perm[perm_access_key] }
+            real_perms = all_perms.reject {|p| p.is_grant?}
+            all_ids = real_perms.collect{ |perm| perm[perm_access_key] }
 
             if all_ids == []
               sql_conds << '2 + 2 = 5'
@@ -919,34 +922,40 @@
 
           klass = self.class.class_for_associate( assoc_name )
 
-          check_foreign_priv = lambda do |priv, foreign_id|
-            if !priv.nil? && !foreign_id.nil?
-              log_hash = {
-                :model_class => klass.name,
-                :model_id    => foreign_id,
-                :privilege   => priv.to_s,
-                :user_id     => User.current.id,
-                :user_name   => User.current.name
-              }
-              if klass.permits_for_id?( priv, foreign_id )
-                log_hash[:success] = true
-                Smartguard::Logging.log( log_hash )
-              else
-                log_hash[:success] = false
-                Smartguard::Logging.log( log_hash )
-                raise PermissionFailure.new("Not authorized to #{priv}",
-                                            :privilege => priv,
-                                            :target_class => klass, 
-                                            :target => foreign_id)
+          if klass.respond_to?( :associate_privilege )
+
+            check_foreign_priv = lambda do |priv, foreign_id|
+              if !priv.nil? && !foreign_id.nil?
+                log_hash = {
+                  :model_class => klass.name,
+                  :model_id    => foreign_id,
+                  :privilege   => priv.to_s,
+                  :user_id     => User.current.id,
+                  :user_name   => User.current.name
+                }
+                if klass.permits_for_id?( priv, foreign_id )
+                  log_hash[:success] = true
+                  RequestLogEntry.note_pcheck( log_hash )
+                else
+                  log_hash[:success] = false
+                  RequestLogEntry.note_pcheck( log_hash )
+                  raise PermissionFailure.new("Not authorized to #{priv}",
+                                              :privilege => priv,
+                                              :target_class => klass, 
+                                              :target => foreign_id)
+                end
               end
             end
-          end
 
-          assoc_prv  = klass.associate_privilege( self.class.name, assoc_name )
-          dissoc_prv = klass.dissociate_privilege(self.class.name, assoc_name )
+            assoc_prv  = klass.associate_privilege( self.class.name, 
+                                                    assoc_name )
+            dissoc_prv = klass.dissociate_privilege( self.class.name, 
+                                                     assoc_name )
 
-          check_foreign_priv.call( dissoc_prv, old_value )
-          check_foreign_priv.call( assoc_prv,  new_value )
+            check_foreign_priv.call( dissoc_prv, old_value )
+            check_foreign_priv.call( assoc_prv,  new_value )
+
+          end
           
         end
 
access_sanity_tests.rb
access_test_helpers.rb
--- access_test_helpers.rb	2008-05-12 16:44:43.000000000 -0400
+++ /home/rst/test/trunk/lib/access_test_helpers.rb	2008-05-12 15:29:48.000000000 -0400
@@ -1,24 +1,3 @@
-#--
-# Copyright (c) 2007 Robert S. Thau, Smartleaf, Inc.
-# 
-# a copy of this software and associated documentation files (the
-# "Software"), to deal in the Software without restriction, including
-# without limitation the rights to use, copy, modify, merge, publish,
-# distribute, sublicense, and/or sell copies of the Software, and to
-# permit persons to whom the Software is furnished to do so, subject to
-# the following conditions:
-# 
-# The above copyright notice and this permission notice shall be
-# included in all copies or substantial portions of the Software.
-# 
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#++
 module Access
  module TestHelpers
 
@@ -42,7 +21,8 @@
       rec.send assign, val
       rec.valid?
       assert !rec.errors.invalid?(field),
-        "#{val} should be valid for #{rec.class}.#{field}"
+        "#{val} should be valid for #{rec.class}.#{field}" + 
+        "\n(#{rec.errors[field].inspect})"
     end
   end
 
@@ -81,7 +61,8 @@
 
       assert_equal 0, user.role_assignments.count
 
-      role = Role.create :name => 'test role'
+      role = Role.create :name => 'test role', 
+        :owner_firm => firms(:dubuque), :owner => user
 
       RoleAssignment.create :user => user, :role => role
 
@@ -161,7 +142,7 @@
       assert_equal 1, user.roles.count
       assert_equal 0, user.permissions.size
 
-      assert_raises( PermissionFailure ) { yield }
+      assert_raises( PermissionFailure, "Should fail with no grants at all" ) { yield }
 
       # If array of one privilege supplied, treat as single privilege
 
@@ -193,7 +174,7 @@
           end
 
           user.permissions :force_reload
-          assert_raises( PermissionFailure ) { yield }
+          assert_raises( PermissionFailure, "Should fail with only priv #{priv.description}" ) { yield }
 
           User.as( users(:universal_grant_guy) ) do
             priv.update_attribute :role, roles(:ricardo_twiddler) # displace...
@@ -302,6 +283,20 @@
   end
 
   # Returns a Permission granting 'privilege' on any object of class 'klass'
+  # whose owner_firm is set to 'firm'.
+
+  def owner_firm_perm privilege, klass, firm
+    Permission.new( :privilege    => privilege,
+                    :class_name   => klass.name,
+                    :is_grant     => false,
+                    :has_grant_option => false,
+                    :target_owned_by_self => false,
+                    :target_owner_firm => firm
+                    )
+    
+  end
+
+  # Returns a Permission granting 'privilege' on any object of class 'klass'
   # which is "owned by self".
 
   def self_owner_perm privilege, klass
DIFFS
smartguard_basic_permission.rb
smartguard_basic_role_assignment.rb
smartguard_basic_role.rb
smartguard_basic_user.rb
smartguard_oracle_monkeypatch.rb
smartguard.rb
